# 🚖 Day 1 — RESTful API Architecture for Ride-Hailing Backend (Node.js + PostgreSQL)

## 🎯 Goal
Design production-grade APIs for a ride-hailing platform Bimride that handle:
- Trip lifecycle (request → match → complete/cancel)
- Driver–rider matching
- Pricing estimation & settlement
- Real-time tracking with REST fallbacks
- Secure payments with idempotency
- Performance target: **<200 ms** for read APIs, **<250 ms** for write APIs (P95)

---

## 🧱 Service Modules

| Service          | Purpose | Scalability Rationale |
|------------------|---------|-----------------------|
| **Trip Service** | Owns trip state machine & lifecycle | Independent scaling for trip events |
| **Matching Service** | Finds best driver via geo-queries & scoring | CPU/IO heavy, needs low latency |
| **Pricing Service** | Estimates & finalizes fares | Deterministic, supports experimentation |
| **Tracking Service** | Provides last-known driver location | TTL-guarded for privacy |
| **Payment Service** | Manages authorizations, captures, refunds | Compliance & idempotency critical |

---

## 🗺️ Key REST Endpoints (v1)

### Trip Management
- `POST /v1/trips` — Create a trip request with pickup/dropoff & payment method
- `POST /v1/trips/{tripId}/match` — Assign best-fit driver
- `POST /v1/trips/{tripId}/accept` — Driver accepts match
- `POST /v1/trips/{tripId}/cancel` — Rider/driver cancels
- `POST /v1/trips/{tripId}/complete` — Finalize trip
- `GET  /v1/trips/{tripId}` — Get trip details
- `GET  /v1/riders/{id}/trips` — Rider trip history (paginated)

### Pricing
- `POST /v1/pricing/estimate` — Pre-ride fare quote
- `POST /v1/pricing/settle` — Final fare settlement

### Matching
- `POST /v1/matching/nearby-drivers` — List drivers within radius, sorted by ETA

### Tracking (REST fallback for WebSockets)
- `GET /v1/tracking/trips/{tripId}/location`
- `GET /v1/tracking/trips/{tripId}/polyline`

### Payments
- `POST /v1/payments/authorize`
- `POST /v1/payments/capture`
- `POST /v1/payments/refund`

---

## 🔒 Security & Idempotency
- **Auth**: JWT access tokens with short TTL; role-based scopes
- **Access Control**:
  - Riders → only their trips
  - Drivers → only assigned trips
- **Idempotency**: All POSTs that mutate state require `Idempotency-Key` header

---

## 🔁 Trip State Machine

REQUESTED → DRIVER_PENDING → ACCEPTED → AT_PICKUP → EN_ROUTE → COMPLETED
↘ (timeout/decline) → REQUESTED
(any) → CANCELED


- Event-sourced for full audit trail
- Illegal transitions blocked at DB & service layer

---

## 🗃️ Core Data Models

### trips
| Column       | Type        | Notes |
|--------------|------------|-------|
| trip_id (PK) | UUID       |       |
| rider_id     | UUID       | FK to riders |
| driver_id    | UUID       | FK to drivers |
| status       | ENUM       | trip state |
| pickup_loc   | GEOGRAPHY  | PostGIS point |
| dropoff_loc  | GEOGRAPHY  | PostGIS point |
| created_at   | TIMESTAMP  | indexed |
| updated_at   | TIMESTAMP  | indexed |

### trip_events
| Column       | Type        |
|--------------|-------------|
| event_id (PK)| UUID        |
| trip_id      | UUID        |
| event_type   | TEXT        |
| event_data   | JSONB       |
| created_at   | TIMESTAMP   |

---

## ⚡ Performance Targets & Tactics
- Redis cache for hot trip reads (TTL 5–10 s)
- PostGIS for spatial queries
- Composite indexes for trip status lookups
- Keyset pagination for trip history
- Avoid N+1 queries with pre-joins or projections

---

## 🧪 Testing & Monitoring
- Postman collection for happy & error paths
- K6 load tests simulating surge hours
- Prometheus metrics: latency histograms, request counts, error rates
- Structured logging with `requestId`

---

## 📌 Deliverables for Day 1
✅ REST routes & DTOs defined  
✅ Trip state machine formalized  
✅ DB schema for trips & events drafted  
✅ Security & idempotency strategy in place  
✅ Performance optimization plan created  

---
