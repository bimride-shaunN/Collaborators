# ðŸš– Day 1 â€” RESTful API Architecture for Ride-Hailing Backend (Node.js + PostgreSQL)

## ðŸŽ¯ Goal
Design production-grade APIs for a ride-hailing platform Bimride that handle:
- Trip lifecycle (request â†’ match â†’ complete/cancel)
- Driverâ€“rider matching
- Pricing estimation & settlement
- Real-time tracking with REST fallbacks
- Secure payments with idempotency
- Performance target: **<200 ms** for read APIs, **<250 ms** for write APIs (P95)

---

## ðŸ§± Service Modules

| Service          | Purpose | Scalability Rationale |
|------------------|---------|-----------------------|
| **Trip Service** | Owns trip state machine & lifecycle | Independent scaling for trip events |
| **Matching Service** | Finds best driver via geo-queries & scoring | CPU/IO heavy, needs low latency |
| **Pricing Service** | Estimates & finalizes fares | Deterministic, supports experimentation |
| **Tracking Service** | Provides last-known driver location | TTL-guarded for privacy |
| **Payment Service** | Manages authorizations, captures, refunds | Compliance & idempotency critical |

---

## ðŸ—ºï¸ Key REST Endpoints (v1)

### Trip Management
- `POST /v1/trips` â€” Create a trip request with pickup/dropoff & payment method
- `POST /v1/trips/{tripId}/match` â€” Assign best-fit driver
- `POST /v1/trips/{tripId}/accept` â€” Driver accepts match
- `POST /v1/trips/{tripId}/cancel` â€” Rider/driver cancels
- `POST /v1/trips/{tripId}/complete` â€” Finalize trip
- `GET  /v1/trips/{tripId}` â€” Get trip details
- `GET  /v1/riders/{id}/trips` â€” Rider trip history (paginated)

### Pricing
- `POST /v1/pricing/estimate` â€” Pre-ride fare quote
- `POST /v1/pricing/settle` â€” Final fare settlement

### Matching
- `POST /v1/matching/nearby-drivers` â€” List drivers within radius, sorted by ETA

### Tracking (REST fallback for WebSockets)
- `GET /v1/tracking/trips/{tripId}/location`
- `GET /v1/tracking/trips/{tripId}/polyline`

### Payments
- `POST /v1/payments/authorize`
- `POST /v1/payments/capture`
- `POST /v1/payments/refund`

---

## ðŸ”’ Security & Idempotency
- **Auth**: JWT access tokens with short TTL; role-based scopes
- **Access Control**:
  - Riders â†’ only their trips
  - Drivers â†’ only assigned trips
- **Idempotency**: All POSTs that mutate state require `Idempotency-Key` header

---

## ðŸ” Trip State Machine

REQUESTED â†’ DRIVER_PENDING â†’ ACCEPTED â†’ AT_PICKUP â†’ EN_ROUTE â†’ COMPLETED
â†˜ (timeout/decline) â†’ REQUESTED
(any) â†’ CANCELED


- Event-sourced for full audit trail
- Illegal transitions blocked at DB & service layer

---

## ðŸ—ƒï¸ Core Data Models

### trips
| Column       | Type        | Notes |
|--------------|------------|-------|
| trip_id (PK) | UUID       |       |
| rider_id     | UUID       | FK to riders |
| driver_id    | UUID       | FK to drivers |
| status       | ENUM       | trip state |
| pickup_loc   | GEOGRAPHY  | PostGIS point |
| dropoff_loc  | GEOGRAPHY  | PostGIS point |
| created_at   | TIMESTAMP  | indexed |
| updated_at   | TIMESTAMP  | indexed |

### trip_events
| Column       | Type        |
|--------------|-------------|
| event_id (PK)| UUID        |
| trip_id      | UUID        |
| event_type   | TEXT        |
| event_data   | JSONB       |
| created_at   | TIMESTAMP   |

---

## âš¡ Performance Targets & Tactics
- Redis cache for hot trip reads (TTL 5â€“10 s)
- PostGIS for spatial queries
- Composite indexes for trip status lookups
- Keyset pagination for trip history
- Avoid N+1 queries with pre-joins or projections

---

## ðŸ§ª Testing & Monitoring
- Postman collection for happy & error paths
- K6 load tests simulating surge hours
- Prometheus metrics: latency histograms, request counts, error rates
- Structured logging with `requestId`

---

## ðŸ“Œ Deliverables for Day 1
âœ… REST routes & DTOs defined  
âœ… Trip state machine formalized  
âœ… DB schema for trips & events drafted  
âœ… Security & idempotency strategy in place  
âœ… Performance optimization plan created  

---
